<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use App\Models\Quiz;
use App\Models\QuizUpload;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Log;

class QuizController extends Controller
{

    public function index()
    {
        $quizzes = Quiz::all();
        return view('quizzes.index', compact('quizzes'));
    }

    public function create()
    {
        return view('quizzes.create');
    }

    public function store(Request $request)
    {
        $request->validate(['title' => 'required|string']);
        Quiz::create($request->only('title', 'description'));
        return redirect()->route('quizzes.index')->with('success', 'Quiz created!');
    }

    public function edit(Quiz $quiz)
    {
        return view('quizzes.edit', compact('quiz'));
    }

    public function update(Request $request, Quiz $quiz)
    {
        $request->validate(['title' => 'required|string']);
        $quiz->update($request->only('title', 'description'));
        return redirect()->route('quizzes.index')->with('success', 'Quiz updated!');
    }

    public function destroy(Quiz $quiz)
    {
        $quiz->delete();
        return redirect()->route('quizzes.index')->with('success', 'Quiz deleted!');
    }




    //AI Quiz Question Generator Methods

    public function showGenerateForm(Quiz $quiz)
    {
        return view('quizzes.generate', compact('quiz'));
    }

    public function generateQuestions(Request $request, Quiz $quiz)
    {
        $request->validate([
            'file' => 'required|file|mimes:pdf,docx,txt|max:10240',
            'question_count' => 'required|integer|min:1|max:20'
        ]);

        $file = $request->file('file');
        $path = $file->store('uploads');

        QuizUpload::create([
            'quiz_id'   => $quiz->id,
            'filename'  => $file->getClientOriginalName(),
            'filepath'  => $path
        ]);

        $contents = $this->extractText($file);

        $count = $request->input('question_count'); // âœ… user-defined count

        $prompt = "
You are an exam question generator.
Read the following course material and generate {$count} multiple-choice questions.
Each question must have exactly 4 options, only one correct.
Return strictly in JSON format like this:

{
  \"questions\": [
    {
      \"question_text\": \"Question here?\",
      \"options\": [
        {\"option_text\": \"Answer 1\", \"is_correct\": 1},
        {\"option_text\": \"Answer 2\", \"is_correct\": 0},
        {\"option_text\": \"Answer 3\", \"is_correct\": 0},
        {\"option_text\": \"Answer 4\", \"is_correct\": 0}
      ]
    }
  ]
}

Course material:
{$contents}
";

        // Call working Gemini method
        $rawText = $this->getGeminiReply($prompt);
        Log::info('AI questions raw output', ['text' => $rawText]);

        // Decode JSON safely
        $data = json_decode($rawText, true);
        if (json_last_error() !== JSON_ERROR_NONE) {
            // Fix simple quotes issues
            $rawTextFixed = str_replace("'", '"', $rawText);
            $data = json_decode($rawTextFixed, true);

            if (json_last_error() !== JSON_ERROR_NONE) {
                Log::error('Failed to decode AI JSON', [
                    'text' => $rawText,
                    'error' => json_last_error_msg()
                ]);
                return redirect()->back()->with('error', 'AI returned invalid JSON. Check logs.');
            }
        }

        $questions = $data['questions'] ?? [];
        if (empty($questions)) {
            Log::warning('No questions generated by AI', ['raw' => $rawText]);
            return redirect()->back()->with('error', 'AI returned no questions.');
        }

        // Store questions and options
        foreach ($questions as $q) {
            if (!isset($q['question_text'], $q['options']) || count($q['options']) !== 4) continue;

            $question = $quiz->questions()->create([
                'question_text' => $q['question_text']
            ]);

            foreach ($q['options'] as $opt) {
                $question->options()->create([
                    'option_text' => $opt['option_text'] ?? 'N/A',
                    'is_correct' => $opt['is_correct'] ?? 0
                ]);
            }
        }

        return redirect()->route('quizzes.questions.index', $quiz)
            ->with('success', 'AI-generated questions saved successfully!');
    }


    /**
     * Fixed Gemini API call
     */
    private function getGeminiReply($prompt)
    {
        $apiKey = env('GEMINI_API_KEY');

        $response = Http::withHeaders([
            'Content-Type' => 'application/json',
        ])->post("https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key={$apiKey}", [
            'contents' => [
                [
                    'parts' => [
                        ['text' => $prompt]
                    ]
                ]
            ],
            'generationConfig' => [
                'response_mime_type' => 'application/json' // force JSON output
            ]
        ]);

        if ($response->successful()) {
            return $response->json()['candidates'][0]['content']['parts'][0]['text'] ?? 'Sorry, no reply.';
        }

        Log::error('Gemini API failed', [
            'status' => $response->status(),
            'body'   => $response->body()
        ]);

        return 'Error reaching Gemini.';
    }



    private function extractText($file)
    {
        $ext = $file->getClientOriginalExtension();
        $text = '';

        if ($ext === 'txt') {
            $text = file_get_contents($file->getRealPath());
        } elseif ($ext === 'pdf') {
            $parser = new \Smalot\PdfParser\Parser();
            $pdf = $parser->parseFile($file->getRealPath());
            $text = $pdf->getText();
        } elseif ($ext === 'docx') {
            $phpWord = \PhpOffice\PhpWord\IOFactory::load($file->getRealPath());

            foreach ($phpWord->getSections() as $section) {
                foreach ($section->getElements() as $element) {
                    $text .= $this->extractTextFromElement($element) . "\n";
                }
            }
        }

        return $text;
    }

    // Helper function to recursively extract text
    private function extractTextFromElement($element)
    {
        $text = '';

        $class = get_class($element);

        switch ($class) {
            case \PhpOffice\PhpWord\Element\TextRun::class:
                foreach ($element->getElements() as $child) {
                    $text .= $this->extractTextFromElement($child);
                }
                break;

            case \PhpOffice\PhpWord\Element\Text::class:
                $text .= $element->getText();
                break;

            case \PhpOffice\PhpWord\Element\TextBreak::class:
                $text .= "\n";
                break;

            case \PhpOffice\PhpWord\Element\Table::class:
                foreach ($element->getRows() as $row) {
                    foreach ($row->getCells() as $cell) {
                        foreach ($cell->getElements() as $cellElement) {
                            $text .= $this->extractTextFromElement($cellElement) . "\t";
                        }
                        $text .= "\n";
                    }
                }
                break;
        }

        return $text;
    }
}
